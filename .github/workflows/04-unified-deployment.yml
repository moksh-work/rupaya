name: 04 - Unified Multi-Environment Deployment

# Unified Deployment Workflow for Dev, Staging, and Production
# Purpose: Single workflow handles all environment deployments with environment-specific config
# Triggers:
#   - feature/** ‚Üí Auto-deploy to Development
#   - release/** ‚Üí Manual approval then Staging
#   - main (tag v*.*.* or push) ‚Üí Manual approval then Production
#   - workflow_dispatch ‚Üí Manual environment selection
#
# Pipeline:
#   Validate (Lint + Unit Tests) ‚Üí Build Image ‚Üí Push to ECR ‚Üí 
#   Deploy Infrastructure (Terraform) ‚Üí Deploy Application (ECS) ‚Üí
#   Run Database Migrations ‚Üí Health Checks ‚Üí E2E Tests ‚Üí Rollback (if failed)

on:
  push:
    branches:
      - 'feature/**'
      - 'release/**'
      - 'main'
    tags:
      - 'v*.*.*'
    paths:
      - 'backend/**'
      - 'shared/**'
      - 'infra/aws/**'
      - '.github/workflows/04-unified-deployment.yml'
      - '!docs/**'
      - '!*.md'

  pull_request:
    branches:
      - develop
    paths:
      - 'backend/**'
      - 'shared/**'
      - '.github/workflows/04-unified-deployment.yml'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      force_deploy:
        description: 'Force deployment (skip approvals)'
        required: false
        type: boolean
        default: false

concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write
  pull-requests: write
  deployments: write

jobs:
  # ========== DETERMINE ENVIRONMENT ==========
  determine-environment:
    name: üîç Determine Target Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      deploy: ${{ steps.set-env.outputs.deploy }}
      image-tag: ${{ steps.set-env.outputs.image-tag }}
    steps:
      - name: Determine environment from trigger
        id: set-env
        run: |
          ENV="none"
          DEPLOY="false"
          TAG="${{ github.sha }}"

          # Manual workflow_dispatch takes precedence
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
            DEPLOY="true"
            echo "‚úì Manual deployment to: $ENV"
          fi

          # Feature branch ‚Üí Development
          if [[ "${{ github.ref }}" == "refs/heads/feature/"* || "${{ github.ref }}" == "refs/heads/bugfix/"* ]]; then
            ENV="dev"
            DEPLOY="true"
            echo "‚úì Feature branch ‚Üí Development"
          fi

          # Release branch ‚Üí Staging
          if [[ "${{ github.ref }}" == "refs/heads/release/"* ]]; then
            ENV="staging"
            DEPLOY="true"
            echo "‚úì Release branch ‚Üí Staging"
          fi

          # Main branch or version tag ‚Üí Production
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" =~ ^refs/tags/v[0-9] ]]; then
            ENV="prod"
            DEPLOY="true"
            TAG="${{ github.ref_name }}"
            echo "‚úì Main branch/version tag ‚Üí Production"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "image-tag=$TAG" >> $GITHUB_OUTPUT

  # ========== VALIDATION STAGE ==========
  validate:
    name: üß™ Validate Code & Tests
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.deploy == 'true'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: rupaya_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: |
          cd backend
          npm ci

      - name: Run linter
        run: |
          cd backend
          npm run lint 2>/dev/null || echo "‚ö†Ô∏è  Linting warnings (non-blocking)"

      - name: Run unit tests
        env:
          NODE_ENV: test
          DATABASE_URL: postgres://test_user:test_password@localhost:5432/rupaya_test
          REDIS_URL: redis://localhost:6379/0
          JWT_SECRET: test_secret_min_32_chars_long_test_secret
          JWT_REFRESH_SECRET: test_refresh_min_32_chars_long_test
        run: |
          cd backend
          npm test -- --coverage --testPathIgnorePatterns=e2e

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: ./backend/coverage/lcov.info
          flags: backend
          fail_ci_if_error: false

  # ========== BUILD DOCKER IMAGE ==========
  build:
    name: üê≥ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [determine-environment, validate]
    outputs:
      image-uri: ${{ steps.image.outputs.image-uri }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      IMAGE_TAG: ${{ needs.determine-environment.outputs.image-tag }}

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets[format('AWS_OIDC_ROLE_ARN_{0}', env.ENVIRONMENT)] }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Get ECR registry
        id: registry
        run: |
          REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ steps.registry.outputs.registry }}

      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ steps.registry.outputs.registry }}/rupaya-backend:latest
            ${{ steps.registry.outputs.registry }}/rupaya-backend:${{ env.IMAGE_TAG }}
            ${{ steps.registry.outputs.registry }}/rupaya-backend:${{ env.ENVIRONMENT }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=${{ env.ENVIRONMENT }}

      - name: Output image URI
        id: image
        run: echo "image-uri=${{ steps.registry.outputs.registry }}/rupaya-backend:${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT

  # ========== TERRAFORM INFRASTRUCTURE DEPLOYMENT ==========
  terraform-plan:
    name: üìã Terraform Plan
    runs-on: ubuntu-latest
    needs: [determine-environment, build]
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      TF_WORKING_DIR: ./infra/aws/environments/${{ needs.determine-environment.outputs.environment }}
    outputs:
      tfplan: ${{ steps.plan.outputs.tfplan }}

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets[format('AWS_OIDC_ROLE_ARN_{0}', env.ENVIRONMENT)] }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Terraform Format Check
        run: |
          cd $TF_WORKING_DIR
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd $TF_WORKING_DIR
          terraform init -upgrade

      - name: Terraform Validate
        run: |
          cd $TF_WORKING_DIR
          terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          cd $TF_WORKING_DIR
          terraform plan -out=tfplan -no-color
          echo "tfplan=tfplan" >> $GITHUB_OUTPUT

      - name: Upload Terraform plan
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: ${{ env.TF_WORKING_DIR }}/tfplan
          retention-days: 5

      - name: Comment plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const planOutput = `${{ steps.plan.outputs.tfplan }}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Terraform Plan for ${{ env.ENVIRONMENT }}\n\`\`\`\n${planOutput}\n\`\`\``
            });

  terraform-apply:
    name: üöÄ Terraform Apply
    runs-on: ubuntu-latest
    needs: [determine-environment, terraform-plan]
    if: needs.determine-environment.outputs.deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      TF_WORKING_DIR: ./infra/aws/environments/${{ needs.determine-environment.outputs.environment }}

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets[format('AWS_OIDC_ROLE_ARN_{0}', env.ENVIRONMENT)] }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Download Terraform plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-${{ env.ENVIRONMENT }}
          path: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: |
          cd $TF_WORKING_DIR
          terraform init -upgrade

      - name: Terraform Apply
        run: |
          cd $TF_WORKING_DIR
          terraform apply -auto-approve tfplan

      - name: Export Terraform outputs
        id: tf-output
        run: |
          cd $TF_WORKING_DIR
          echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT
          echo "redis_endpoint=$(terraform output -raw redis_endpoint)" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

  # ========== ECS DEPLOYMENT ==========
  deploy-ecs:
    name: üì¶ Deploy to ECS
    runs-on: ubuntu-latest
    needs: [determine-environment, build, terraform-apply]
    if: needs.determine-environment.outputs.deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      IMAGE_URI: ${{ needs.build.outputs.image-uri }}

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets[format('AWS_OIDC_ROLE_ARN_{0}', env.ENVIRONMENT)] }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Get ECS cluster and service names
        id: ecs
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          if [ "$ENVIRONMENT" == "dev" ]; then
            CLUSTER="rupaya-dev"
            SERVICE="rupaya-backend-dev"
          elif [ "$ENVIRONMENT" == "staging" ]; then
            CLUSTER="rupaya-staging"
            SERVICE="rupaya-backend-staging"
          else
            CLUSTER="rupaya-prod"
            SERVICE="rupaya-backend-prod"
          fi
          echo "cluster=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service=$SERVICE" >> $GITHUB_OUTPUT

      - name: Update ECS task definition
        id: task-def
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ steps.ecs.outputs.service }} \
            --region us-east-1 | jq '.taskDefinition | del(.taskDefinitionArn, .revision, .status, .requiresAttributes)' > task-definition.json
          
          # Update image in task definition
          jq ".containerDefinitions[0].image = \"${{ env.IMAGE_URI }}\"" task-definition.json > task-definition-updated.json

      - name: Register new task definition
        id: new-task-def
        run: |
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition-updated.json \
            --region us-east-1 \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task-definition=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Deploy to ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ steps.ecs.outputs.cluster }} \
            --service ${{ steps.ecs.outputs.service }} \
            --task-definition ${{ steps.new-task-def.outputs.task-definition }} \
            --force-new-deployment \
            --region us-east-1

      - name: Wait for ECS service to stabilize
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster }} \
            --services ${{ steps.ecs.outputs.service }} \
            --region us-east-1 \
            --max-attempts 40

  # ========== DATABASE MIGRATIONS ==========
  database-migrations:
    name: üóÑÔ∏è Run Database Migrations
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-ecs]
    if: needs.determine-environment.outputs.deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Get RDS endpoint
        id: rds
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          cd backend
          npm ci --omit=dev

      - name: Run migrations
        env:
          NODE_ENV: ${{ env.ENVIRONMENT }}
          DATABASE_URL: ${{ secrets[format('DB_URL_{0}', env.ENVIRONMENT)] }}
          REDIS_URL: ${{ secrets[format('REDIS_URL_{0}', env.ENVIRONMENT)] }}
        run: |
          cd backend
          npm run migrate:${{ env.ENVIRONMENT }} || npm run migrate

  # ========== HEALTH CHECKS ==========
  health-check:
    name: üè• Health Checks
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-ecs]
    if: needs.determine-environment.outputs.deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - name: Get ALB endpoint
        id: alb
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          if [ "$ENVIRONMENT" == "dev" ]; then
            ALB_URL="http://rupaya-dev-alb.us-east-1.elb.amazonaws.com"
          elif [ "$ENVIRONMENT" == "staging" ]; then
            ALB_URL="http://rupaya-staging-alb.us-east-1.elb.amazonaws.com"
          else
            ALB_URL="http://rupaya-prod-alb.us-east-1.elb.amazonaws.com"
          fi
          echo "alb-url=$ALB_URL" >> $GITHUB_OUTPUT

      - name: Wait for application readiness
        run: |
          MAX_ATTEMPTS=10
          ATTEMPT=0
          TIMEOUT=60
          START_TIME=$(date +%s)

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."

            if curl -f -s -m 5 "${{ steps.alb.outputs.alb-url }}/health" > /dev/null 2>&1; then
              echo "‚úÖ Application is healthy"
              exit 0
            fi

            ELAPSED=$(($(date +%s) - START_TIME))
            if [ $ELAPSED -gt $TIMEOUT ]; then
              echo "‚è±Ô∏è  Timeout exceeded ($TIMEOUT seconds)"
              exit 1
            fi

            sleep $((TIMEOUT / MAX_ATTEMPTS))
          done

          echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
          exit 1

  # ========== E2E TESTS ==========
  e2e-tests:
    name: üß¨ E2E Tests
    runs-on: ubuntu-latest
    needs: [determine-environment, health-check]
    if: needs.determine-environment.outputs.deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: |
          cd backend
          npm ci

      - name: Get API endpoint
        id: api
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          if [ "$ENVIRONMENT" == "dev" ]; then
            API_URL="http://rupaya-dev-alb.us-east-1.elb.amazonaws.com"
          elif [ "$ENVIRONMENT" == "staging" ]; then
            API_URL="http://rupaya-staging-alb.us-east-1.elb.amazonaws.com"
          else
            API_URL="http://rupaya-prod-alb.us-east-1.elb.amazonaws.com"
          fi
          echo "api-url=$API_URL" >> $GITHUB_OUTPUT

      - name: Run E2E tests
        env:
          API_URL: ${{ steps.api.outputs.api-url }}
          NODE_ENV: test
        run: |
          cd backend
          npm run test:e2e 2>/dev/null || npm test -- --testPathPattern=e2e --ci --coverage

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: e2e-test-results-${{ env.ENVIRONMENT }}
          path: backend/coverage
          retention-days: 7

  # ========== DEPLOYMENT REPORT ==========
  deployment-summary:
    name: üìä Deployment Summary
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-ecs, e2e-tests]
    if: always()
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - name: Generate deployment summary
        run: |
          cat << 'EOF'
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë          üéâ DEPLOYMENT COMPLETE üéâ                        ‚ïë
          ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
          ‚ïë Environment: ${{ env.ENVIRONMENT }}
          ‚ïë Commit SHA: ${{ github.sha }}
          ‚ïë Branch: ${{ github.ref_name }}
          ‚ïë Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
          ‚ïë Status:
          ‚ïë   ‚úÖ Code Validation: PASSED
          ‚ïë   ‚úÖ Docker Build: PASSED
          ‚ïë   ‚úÖ Infrastructure: DEPLOYED
          ‚ïë   ‚úÖ Database Migrations: COMPLETED
          ‚ïë   ‚úÖ Health Checks: PASSED
          ‚ïë   ‚úÖ E2E Tests: PASSED
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          EOF

      - name: Notify deployment
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚úÖ **Deployment to ${{ env.ENVIRONMENT }}** completed successfully!\n\n**Commit:** ${{ github.sha }}\n**Branch:** ${{ github.ref_name }}`
            });

  # ========== ROLLBACK (on failure) ==========
  rollback:
    name: üîÑ Automatic Rollback
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-ecs, e2e-tests]
    if: failure() && needs.determine-environment.outputs.deploy == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets[format('AWS_OIDC_ROLE_ARN_{0}', env.ENVIRONMENT)] }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Get ECS service details
        id: ecs
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          if [ "$ENVIRONMENT" == "dev" ]; then
            CLUSTER="rupaya-dev"
            SERVICE="rupaya-backend-dev"
          elif [ "$ENVIRONMENT" == "staging" ]; then
            CLUSTER="rupaya-staging"
            SERVICE="rupaya-backend-staging"
          else
            CLUSTER="rupaya-prod"
            SERVICE="rupaya-backend-prod"
          fi
          echo "cluster=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service=$SERVICE" >> $GITHUB_OUTPUT

      - name: Get previous stable task definition
        id: prev-task
        run: |
          PREV_TASK=$(aws ecs describe-services \
            --cluster ${{ steps.ecs.outputs.cluster }} \
            --services ${{ steps.ecs.outputs.service }} \
            --region us-east-1 \
            --query 'services[0].deployments[1].taskDefinition' \
            --output text)
          echo "task-definition=$PREV_TASK" >> $GITHUB_OUTPUT

      - name: Rollback to previous task definition
        if: steps.prev-task.outputs.task-definition != 'None'
        run: |
          aws ecs update-service \
            --cluster ${{ steps.ecs.outputs.cluster }} \
            --service ${{ steps.ecs.outputs.service }} \
            --task-definition ${{ steps.prev-task.outputs.task-definition }} \
            --force-new-deployment \
            --region us-east-1

      - name: Wait for rollback to complete
        if: steps.prev-task.outputs.task-definition != 'None'
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster }} \
            --services ${{ steps.ecs.outputs.service }} \
            --region us-east-1

      - name: Notify rollback
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚ö†Ô∏è **Deployment to ${{ env.ENVIRONMENT }} FAILED** - Automatic rollback initiated. Check logs for details.`
            });
