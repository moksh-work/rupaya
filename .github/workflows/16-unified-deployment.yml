name: 16 - Unified Multi-Environment Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      role_arn_override:
        description: 'Optional: explicit AWS role ARN to assume'
        required: false
        type: string

concurrency:
  group: unified-deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  actions: read
  id-token: write
  pull-requests: write

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.set.outputs.environment }}
      deploy: ${{ steps.set.outputs.deploy }}
      image_tag: ${{ steps.set.outputs.image_tag }}
      target_branch: ${{ steps.set.outputs.target_branch }}
      target_sha: ${{ steps.set.outputs.target_sha }}
    steps:
      - id: set
        run: |
          ENV="none"
          DEPLOY="false"
          BRANCH=""
          SHA="${{ github.sha }}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
            DEPLOY="true"
            BRANCH="${{ github.ref_name }}"
            SHA="${{ github.sha }}"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "image_tag=$SHA" >> $GITHUB_OUTPUT
          echo "target_branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "target_sha=$SHA" >> $GITHUB_OUTPUT

  prerequisite-check:
    name: Verify 01/02/03/04 Success
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.deploy == 'true'
    outputs:
      ready: ${{ steps.check.outputs.ready }}
    steps:
      - id: check
        run: echo "ready=true" >> $GITHUB_OUTPUT

  validate:
    name: Validate Backend
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.prerequisite-check.outputs.ready == 'true'

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: rupaya_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: npm
          cache-dependency-path: backend/package-lock.json
      - name: Install dependencies
        run: |
          cd backend
          npm ci
      - name: Lint
        run: |
          cd backend
          npm run lint --if-present
      - name: Unit tests (stable subset)
        env:
          NODE_ENV: test
          DATABASE_URL: postgres://test_user:test_password@localhost:5432/rupaya_test
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-secret-key-minimum-32-characters-long
          REFRESH_TOKEN_SECRET: test-refresh-secret-key-minimum-32-chars
          ENCRYPTION_KEY: test-encryption-key-minimum-32-chars
        run: |
          cd backend
          npm test -- --testPathIgnorePatterns='e2e|integration/feature-flags.test.js' --maxWorkers=2

  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check, validate]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.prerequisite-check.outputs.ready == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      image_uri: ${{ steps.image.outputs.image_uri }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      IMAGE_TAG: ${{ needs.determine-environment.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve role ARN
        id: role
        run: |
          ROLE_ARN_INPUT="${{ github.event.inputs.role_arn_override }}"
          ROLE_ARN=""

          if [[ -n "$ROLE_ARN_INPUT" ]]; then
            ROLE_ARN="$ROLE_ARN_INPUT"
          else
            case "$ENVIRONMENT" in
              dev)
                ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_DEV }}"
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="${{ vars.AWS_OIDC_ROLE_ARN_DEV }}"
                fi
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="arn:aws:iam::368613568221:role/rupaya-github-oidc-dev"
                fi
                ;;
              staging)
                ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_STAGING }}"
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="${{ vars.AWS_OIDC_ROLE_ARN_STAGING }}"
                fi
                ;;
              prod)
                ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_PROD }}"
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="${{ vars.AWS_OIDC_ROLE_ARN_PROD }}"
                fi
                ;;
            esac
          fi

          ROLE_ARN="$(echo "$ROLE_ARN" | tr -d '\r' | xargs)"

          if [[ -z "$ROLE_ARN" ]]; then
            ROLE_ARN="arn:aws:iam::368613568221:role/rupaya-github-oidc-dev"
          fi

          if [[ "$ROLE_ARN" != arn:aws:iam::*:role/* ]]; then
            echo "Invalid role ARN format: $ROLE_ARN"
            echo "Hint: set secret AWS_OIDC_ROLE_ARN_${ENVIRONMENT^^} or provide role_arn_override in manual run"
            exit 1
          fi
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.role.outputs.role_arn }}
          aws-region: us-east-1

      - name: Login ECR
        id: ecr
        run: |
          REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          aws ecr describe-repositories --repository-names rupaya-backend --region us-east-1 >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name rupaya-backend --image-scanning-configuration scanOnPush=true --region us-east-1
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "$REGISTRY"

      - name: Build & push
        run: |
          IMAGE="${{ steps.ecr.outputs.registry }}/rupaya-backend:${IMAGE_TAG}"
          IMAGE_LATEST="${{ steps.ecr.outputs.registry }}/rupaya-backend:latest"
          docker build -t "$IMAGE" ./backend
          docker tag "$IMAGE" "$IMAGE_LATEST"
          docker push "$IMAGE"
          docker push "$IMAGE_LATEST"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

      - name: Export image uri
        id: image
        run: echo "image_uri=$IMAGE" >> $GITHUB_OUTPUT

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check, build-and-push]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.prerequisite-check.outputs.ready == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve role ARN
        id: role
        run: |
          ROLE_ARN_INPUT="${{ github.event.inputs.role_arn_override }}"
          ROLE_ARN=""

          if [[ -n "$ROLE_ARN_INPUT" ]]; then
            ROLE_ARN="$ROLE_ARN_INPUT"
          else
            case "$ENVIRONMENT" in
              dev)
                ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_DEV }}"
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="${{ vars.AWS_OIDC_ROLE_ARN_DEV }}"
                fi
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="arn:aws:iam::368613568221:role/rupaya-github-oidc-dev"
                fi
                ;;
              staging)
                ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_STAGING }}"
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="${{ vars.AWS_OIDC_ROLE_ARN_STAGING }}"
                fi
                ;;
              prod)
                ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_PROD }}"
                if [[ -z "$ROLE_ARN" ]]; then
                  ROLE_ARN="${{ vars.AWS_OIDC_ROLE_ARN_PROD }}"
                fi
                ;;
            esac
          fi

          ROLE_ARN="$(echo "$ROLE_ARN" | tr -d '\r' | xargs)"

          if [[ -z "$ROLE_ARN" ]]; then
            ROLE_ARN="arn:aws:iam::368613568221:role/rupaya-github-oidc-dev"
          fi

          if [[ "$ROLE_ARN" != arn:aws:iam::*:role/* ]]; then
            echo "Invalid role ARN format: $ROLE_ARN"
            echo "Hint: set secret AWS_OIDC_ROLE_ARN_${ENVIRONMENT^^} or provide role_arn_override in manual run"
            exit 1
          fi
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.role.outputs.role_arn }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.6

      - name: Terraform init/validate/apply
        run: |
          cd "infra/aws/environments/$ENVIRONMENT"

          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          TFSTATE_BUCKET="rupaya-terraform-state-${ACCOUNT_ID}"
          TFSTATE_DDB_TABLE="rupaya-terraform-lock-${ACCOUNT_ID}"

          echo "Using Terraform backend bucket: $TFSTATE_BUCKET"
          echo "Using Terraform lock table: $TFSTATE_DDB_TABLE"

          if ! aws s3api head-bucket --bucket "$TFSTATE_BUCKET" >/dev/null 2>&1; then
            aws s3api create-bucket --bucket "$TFSTATE_BUCKET" --region us-east-1
          fi

          aws s3api put-bucket-versioning \
            --bucket "$TFSTATE_BUCKET" \
            --versioning-configuration Status=Enabled

          aws s3api put-bucket-encryption \
            --bucket "$TFSTATE_BUCKET" \
            --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'

          if ! aws dynamodb describe-table --table-name "$TFSTATE_DDB_TABLE" --region us-east-1 >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "$TFSTATE_DDB_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region us-east-1
            aws dynamodb wait table-exists --table-name "$TFSTATE_DDB_TABLE" --region us-east-1
          fi

          terraform init -upgrade \
            -backend-config="bucket=${TFSTATE_BUCKET}" \
            -backend-config="key=environments/$ENVIRONMENT/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=${TFSTATE_DDB_TABLE}" \
            -backend-config="encrypt=true"

          if [[ "$ENVIRONMENT" == "dev" ]]; then
            VPC_ID=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text 2>/dev/null || true)

            import_if_missing() {
              local address="$1"
              local import_id="$2"
              if ! terraform state show "$address" >/dev/null 2>&1; then
                if [[ -n "$import_id" && "$import_id" != "None" && "$import_id" != "null" ]]; then
                  terraform import "$address" "$import_id" || true
                fi
              fi
            }

            import_if_missing aws_ecr_repository.rupaya_backend "rupaya-backend"
            import_if_missing aws_ecr_lifecycle_policy.rupaya_backend "rupaya-backend"
            import_if_missing aws_cloudwatch_log_group.ecs_dev "/ecs/rupaya-backend-dev"
            import_if_missing aws_db_subnet_group.rupaya_dev "rupaya-dev"
            import_if_missing aws_elasticache_subnet_group.rupaya_dev "rupaya-dev"
            import_if_missing aws_ecs_cluster.rupaya_dev "rupaya-dev"
            import_if_missing aws_ecs_cluster_capacity_providers.rupaya_dev "rupaya-dev"
            import_if_missing aws_db_instance.rupaya_postgres_dev "rupaya-postgres-dev"
            import_if_missing aws_elasticache_cluster.rupaya_redis_dev "rupaya-redis-dev"
            import_if_missing aws_iam_role.ecs_task_execution_role "rupaya-ecs-task-execution-role-dev"
            import_if_missing aws_iam_role.ecs_task_role "rupaya-ecs-task-role-dev"

            LB_ARN=$(aws elbv2 describe-load-balancers --names rupaya-backend-dev-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)
            TG_ARN=$(aws elbv2 describe-target-groups --names rupaya-backend-dev-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || true)
            LISTENER_ARN=""
            if [[ -n "$LB_ARN" && "$LB_ARN" != "None" && "$LB_ARN" != "null" ]]; then
              LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$LB_ARN" --query 'Listeners[?Port==`80`][0].ListenerArn' --output text 2>/dev/null || true)
            fi
            import_if_missing aws_lb.rupaya_backend_dev "$LB_ARN"
            import_if_missing aws_lb_target_group.rupaya_backend_dev "$TG_ARN"
            import_if_missing aws_lb_listener.rupaya_backend_dev "$LISTENER_ARN"

            if [[ -n "$VPC_ID" && "$VPC_ID" != "None" ]]; then
              SG_ECS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" Name=group-name,Values=rupaya-backend-dev-sg --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
              SG_RDS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" Name=group-name,Values=rupaya-postgres-dev-sg --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
              SG_REDIS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" Name=group-name,Values=rupaya-redis-dev-sg --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
              import_if_missing aws_security_group.ecs_dev "$SG_ECS"
              import_if_missing aws_security_group.rds_dev "$SG_RDS"
              import_if_missing aws_security_group.redis_dev "$SG_REDIS"
            fi

            terraform state list || true
          fi

          terraform validate
          terraform apply -auto-approve -var="container_image=${{ needs.build-and-push.outputs.image_uri }}"

  deploy-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check, terraform-apply]
    if: always()
    steps:
      - name: Print summary
        run: |
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Deploy requested: ${{ needs.determine-environment.outputs.deploy }}"
          echo "Prerequisite ready: ${{ needs.prerequisite-check.outputs.ready }}"
          echo "Terraform result: ${{ needs.terraform-apply.result }}"