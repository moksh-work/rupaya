name: 16 - Unified Multi-Environment Deployment

on:
  workflow_run:
    workflows:
      - "01 - Fast Feedback (Smoke Tests & Validation)"
      - "02 - Mobile Build Check"
      - "03 - Android Build & Release"
      - "04 - iOS Build & Release"
    types:
      - completed

  push:
    branches:
      - feature/**
      - bugfix/**
      - chore/**
      - main
      - release/**
    tags:
      - 'v*.*.*'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

concurrency:
  group: unified-deploy-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  actions: read
  id-token: write
  pull-requests: write

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set.outputs.environment }}
      deploy: ${{ steps.set.outputs.deploy }}
      image_tag: ${{ steps.set.outputs.image_tag }}
      target_branch: ${{ steps.set.outputs.target_branch }}
      target_sha: ${{ steps.set.outputs.target_sha }}
    steps:
      - id: set
        run: |
          ENV="none"
          DEPLOY="false"
          BRANCH=""
          SHA="${{ github.sha }}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
            DEPLOY="true"
            BRANCH="manual"
            SHA="${{ github.sha }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            SHA="${{ github.event.workflow_run.head_sha }}"
            if [[ "$BRANCH" == feature/* || "$BRANCH" == bugfix/* || "$BRANCH" == chore/* ]]; then
              ENV="dev"
              DEPLOY="true"
            fi
          elif [[ "${{ github.ref }}" == refs/heads/feature/* || "${{ github.ref }}" == refs/heads/bugfix/* || "${{ github.ref }}" == refs/heads/chore/* ]]; then
            ENV="dev"
            DEPLOY="true"
            BRANCH="${{ github.ref_name }}"
          elif [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            ENV="staging"
            DEPLOY="true"
            BRANCH="${{ github.ref_name }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == refs/tags/v* ]]; then
            ENV="prod"
            DEPLOY="true"
            BRANCH="${{ github.ref_name }}"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "image_tag=$SHA" >> $GITHUB_OUTPUT
          echo "target_branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "target_sha=$SHA" >> $GITHUB_OUTPUT

  prerequisite-check:
    name: Verify 01/02/03/04 Success
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.deploy == 'true'
    outputs:
      ready: ${{ steps.check.outputs.ready }}
    steps:
      - id: check
        uses: actions/github-script@v7
        with:
          script: |
            const isWorkflowRun = context.eventName === 'workflow_run';
            if (!isWorkflowRun) {
              core.setOutput('ready', 'true');
              return;
            }

            const required = [
              '01 - Fast Feedback (Smoke Tests & Validation)',
              '02 - Mobile Build Check',
              '03 - Android Build & Release',
              '04 - iOS Build & Release'
            ];

            const sha = context.payload.workflow_run.head_sha;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const runs = await github.paginate(github.rest.actions.listWorkflowRunsForRepo, {
              owner,
              repo,
              head_sha: sha,
              per_page: 100
            });

            const latestByName = {};
            for (const run of runs) {
              if (!required.includes(run.name)) continue;
              if (!latestByName[run.name] || new Date(run.created_at) > new Date(latestByName[run.name].created_at)) {
                latestByName[run.name] = run;
              }
            }

            const missing = [];
            const failed = [];
            for (const name of required) {
              const run = latestByName[name];
              if (!run) {
                missing.push(name);
              } else if (run.conclusion !== 'success') {
                failed.push(`${name} (${run.conclusion || 'no conclusion'})`);
              }
            }

            const ready = missing.length === 0 && failed.length === 0;
            core.setOutput('ready', ready ? 'true' : 'false');

            if (!ready) {
              core.warning(`Prerequisites not ready. Missing: ${missing.join(', ') || 'none'}; Failed: ${failed.join(', ') || 'none'}`);
            }

  validate:
    name: Validate Backend
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.prerequisite-check.outputs.ready == 'true'

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: rupaya_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: npm
          cache-dependency-path: backend/package-lock.json
      - name: Install dependencies
        run: |
          cd backend
          npm ci
      - name: Lint
        run: |
          cd backend
          npm run lint --if-present
      - name: Unit tests (stable subset)
        env:
          NODE_ENV: test
          DATABASE_URL: postgres://test_user:test_password@localhost:5432/rupaya_test
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-secret-key-minimum-32-characters-long
          REFRESH_TOKEN_SECRET: test-refresh-secret-key-minimum-32-chars
          ENCRYPTION_KEY: test-encryption-key-minimum-32-chars
        run: |
          cd backend
          npm test -- --testPathIgnorePatterns='e2e|integration/feature-flags.test.js' --maxWorkers=2

  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check, validate]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.prerequisite-check.outputs.ready == 'true'
    outputs:
      image_uri: ${{ steps.image.outputs.image_uri }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      IMAGE_TAG: ${{ needs.determine-environment.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve role ARN
        id: role
        run: |
          ROLE_ARN=""
          case "$ENVIRONMENT" in
            dev)
              ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_DEV }}"
              if [[ -z "$ROLE_ARN" || "$ROLE_ARN" != arn:aws:iam::*:role/* ]]; then
                ROLE_ARN="arn:aws:iam::992382556348:role/rupaya-github-oidc-dev"
              fi
              ;;
            staging)
              ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_STAGING }}"
              ;;
            prod)
              ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_PROD }}"
              ;;
            *) exit 1 ;;
          esac
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.role.outputs.role_arn }}
          aws-region: us-east-1

      - name: Login ECR
        id: ecr
        run: |
          REGISTRY=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          aws ecr describe-repositories --repository-names rupaya-backend --region us-east-1 >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name rupaya-backend --image-scanning-configuration scanOnPush=true --region us-east-1
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "$REGISTRY"

      - name: Build & push
        run: |
          IMAGE="${{ steps.ecr.outputs.registry }}/rupaya-backend:${IMAGE_TAG}"
          docker build -t "$IMAGE" ./backend
          docker push "$IMAGE"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

      - name: Export image uri
        id: image
        run: echo "image_uri=$IMAGE" >> $GITHUB_OUTPUT

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check, build-and-push]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.prerequisite-check.outputs.ready == 'true'
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve role ARN
        id: role
        run: |
          ROLE_ARN=""
          case "$ENVIRONMENT" in
            dev)
              ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_DEV }}"
              if [[ -z "$ROLE_ARN" || "$ROLE_ARN" != arn:aws:iam::*:role/* ]]; then
                ROLE_ARN="arn:aws:iam::992382556348:role/rupaya-github-oidc-dev"
              fi
              ;;
            staging)
              ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_STAGING }}"
              ;;
            prod)
              ROLE_ARN="${{ secrets.AWS_OIDC_ROLE_ARN_PROD }}"
              ;;
            *) exit 1 ;;
          esac
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.role.outputs.role_arn }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.6

      - name: Terraform init/validate/apply
        run: |
          cd "infra/aws/environments/$ENVIRONMENT"

          terraform init -upgrade \
            -backend-config="bucket=rupaya-terraform-state" \
            -backend-config="key=environments/$ENVIRONMENT/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=rupaya-terraform-lock" \
            -backend-config="encrypt=true"

          if [[ "$ENVIRONMENT" == "dev" ]]; then
            VPC_ID=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text 2>/dev/null || true)

            import_if_missing() {
              local address="$1"
              local import_id="$2"
              if ! terraform state show "$address" >/dev/null 2>&1; then
                if [[ -n "$import_id" && "$import_id" != "None" && "$import_id" != "null" ]]; then
                  terraform import "$address" "$import_id" || true
                fi
              fi
            }

            import_if_missing aws_ecr_repository.rupaya_backend "rupaya-backend"
            import_if_missing aws_ecr_lifecycle_policy.rupaya_backend "rupaya-backend"
            import_if_missing aws_cloudwatch_log_group.ecs_dev "/ecs/rupaya-backend-dev"
            import_if_missing aws_db_subnet_group.rupaya_dev "rupaya-dev"
            import_if_missing aws_elasticache_subnet_group.rupaya_dev "rupaya-dev"
            import_if_missing aws_ecs_cluster.rupaya_dev "rupaya-dev"
            import_if_missing aws_ecs_cluster_capacity_providers.rupaya_dev "rupaya-dev"
            import_if_missing aws_db_instance.rupaya_postgres_dev "rupaya-postgres-dev"
            import_if_missing aws_elasticache_cluster.rupaya_redis_dev "rupaya-redis-dev"
            import_if_missing aws_iam_role.ecs_task_execution_role "rupaya-ecs-task-execution-role-dev"
            import_if_missing aws_iam_role.ecs_task_role "rupaya-ecs-task-role-dev"

            LB_ARN=$(aws elbv2 describe-load-balancers --names rupaya-backend-dev-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)
            TG_ARN=$(aws elbv2 describe-target-groups --names rupaya-backend-dev-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || true)
            LISTENER_ARN=""
            if [[ -n "$LB_ARN" && "$LB_ARN" != "None" && "$LB_ARN" != "null" ]]; then
              LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$LB_ARN" --query 'Listeners[?Port==`80`][0].ListenerArn' --output text 2>/dev/null || true)
            fi
            import_if_missing aws_lb.rupaya_backend_dev "$LB_ARN"
            import_if_missing aws_lb_target_group.rupaya_backend_dev "$TG_ARN"
            import_if_missing aws_lb_listener.rupaya_backend_dev "$LISTENER_ARN"

            if [[ -n "$VPC_ID" && "$VPC_ID" != "None" ]]; then
              SG_ECS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" Name=group-name,Values=rupaya-backend-dev-sg --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
              SG_RDS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" Name=group-name,Values=rupaya-postgres-dev-sg --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
              SG_REDIS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" Name=group-name,Values=rupaya-redis-dev-sg --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
              import_if_missing aws_security_group.ecs_dev "$SG_ECS"
              import_if_missing aws_security_group.rds_dev "$SG_RDS"
              import_if_missing aws_security_group.redis_dev "$SG_REDIS"
            fi

            terraform state list || true
          fi

          terraform validate
          terraform apply -auto-approve -var="container_image=${{ needs.build-and-push.outputs.image_uri }}"

  deploy-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [determine-environment, prerequisite-check, terraform-apply]
    if: always()
    steps:
      - name: Print summary
        run: |
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Deploy requested: ${{ needs.determine-environment.outputs.deploy }}"
          echo "Prerequisite ready: ${{ needs.prerequisite-check.outputs.ready }}"
          echo "Terraform result: ${{ needs.terraform-apply.result }}"